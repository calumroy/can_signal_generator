#!/usr/bin/env python3

"""
A python script to send CAN messages onto a can bus.

Read a DBC file and a configuration file and generator signals to write to a CAN bus.
This tool generates steps and sin wave signals for any field within a CAN message defined in a DBC file.
It runs a test where multiple signals are generated depending on the config file.

Simple usage example:
    python3 can_signal_generator.py -p ./config/params_test1.yaml

NOTES:
    Make sure the specified CAN DBC file exist at the location speicifed in the config file.
    Make sure the CAN interface speicfied in the config exist and has been setup.
    E.g to setup a virtual can buses in linux run this bash script as sudo:
        ```
        #!/bin/bash
        (( EUID == 0 )) || { echo "This script must be run with root privileges" ; exit 1; }
        echo "setting up virtual can interface"
        modprobe vcan

        ip link add dev can3 type vcan
        ip link set up can3
        ```

"""

import os
import sys
import math
import argparse
import time
import yaml
import cantools
import can
import sim_timer as simtimer

# Global vars default parameters
SIG_GEN_CLOCK = None
START_TIME = None
DEFAULT_CAN_VALUE = 0.0


class CanStepSignalGenerator: # pylint: disable=too-many-instance-attributes
    """
    A Class defining a step signal generator.

    Args:
        name (string): The name of the CAN message.
        step_value (list): List of floats defining the amplitudes to step the signal to at the corresponding times definied in duraitons or time list.
        step_durations (list): List of floats defining how long to wait in seconds since the last step at the current step value.
                               Note use either step_durations or step_times but not both. Set the unused one to None.
        step_times (list): List of floats defining the timestamps in seconds to step to the next value.
                           Note use either step_durations or step_times but not both. Set the unused one to None.
    """
    def __init__(self, name, step_value, step_durations, step_times):
        self.name = name
        self.can_name = name.split('.')[0]
        self.field_name = name.split('.')[1]
        self.duration = None
        self.times = None
        # Keep track of what index the signal generator is up to in the value and duration lists.
        # This can be set to None if the current time does not have a value specified, e.g if using the times list, before the first timestamp has passed.
        self.cur_index = 0
        # Step information
        self.value = step_value
        if step_durations is not None:
            self.using_duration = True
            self.duration = step_durations
            self.cumulative_duration_time = sum(self.duration[0:self.cur_index]) # Keep track of the sum of the duration times up to the current index.
        else:
            self.using_duration = False
            self.times = step_times
            self.cumulative_duration_time = self.times[0] # Keep track of the sum of the duration times up to the current index.

    def update_time(self, cur_time): # pylint: disable=too-many-branches
        """
        Update the time for the sinusoidal signal generator class.
        This will be used internally to update the signal value that is generated by this class.
        This actually just updates the list index that the class is using to keep track of where it is up to in the config files specified values list.

        Args:
            cur_time (float): The current time in seconds.
        """
        if self.using_duration: # pylint: disable=too-many-nested-blocks
            if cur_time > self.cumulative_duration_time:
                duration_idx = 0
                for i in range(1, len(self.duration)+1):
                    if cur_time < sum(self.duration[0:i]):
                        duration_idx = i - 1 # We are up to the previous time index in the duration array.
                        break
                self.cur_index = duration_idx
                self.cumulative_duration_time = sum(self.duration[0:self.cur_index])
        else:
            # We are using a times list for this signal instead of the time durations. At the time specified step to the corresponding value.
            # Send the default value until the first time specified in the times list has passed.
            if cur_time > self.times[0]:
                if self.cur_index is None:
                    self.cur_index = 0
                # Make sure the current index is not pointing to the last timestamp.
                if (self.cur_index < len(self.times) - 1):
                    if cur_time > self.times[self.cur_index + 1]:
                        for index, value in enumerate(self.times):
                            if cur_time < value:
                                break
                            else:
                                self.cur_index = index
                else:
                    # The last timestamp specified has passed, no more updating this signals value.
                    pass
            else:
                # The first timestamp specified to step a signal needs to be handled differently.
                # This is because while the clock is less then this time stamp only write the default value.
                self.cur_index = None
                self.cumulative_duration_time = 0.0

    def get_value(self):
        """
            Return the value from the sin signal generator for the current offset time.
            If the signal does not have a value specified yet then return the default CAN value.

        Returns:
            float: The vlaue of the signal at the current time.
        """
        global DEFAULT_CAN_VALUE # pylint: disable=global-statement
        # Return the value from the step signal generator for the current time.
        if self.cur_index is not None:
            return self.value[self.cur_index]
        # Publish the defualt value. The signal does not have a value definied for the current time. Publish the default value.
        return DEFAULT_CAN_VALUE

class CanSinSignalGenerator: # pylint: disable=too-many-instance-attributes
    """
    A Class defining a sinusoidal signal generator.

    Args:
        name (string): The name of the CAN message.
        sin_amplitude (float): The amplitude of the sinusoidal signal that is generated.
        sin_period (float): The period of the sinusoidal signal that is generated.
        sin_start_time (float): The start time (in seconds after the tool is started) when the sinusoidal signal will start to be generated.
        sin_duration (float): The time in seconds that the sinusoidal signal will be generated for after beginning.
    """
    def __init__(self, name, sin_amplitude, sin_period, sin_start_time, sin_duration): # pylint: disable=too-many-arguments
        self.name = name
        self.can_name = name.split('.')[0]
        self.field_name = name.split('.')[1]
        # Sinusoidal information
        self.amplitude = sin_amplitude
        self.period = sin_period
        self.start_time = sin_start_time
        self.duration = sin_duration # Amount of time to send a sin wave signal for.
        # Timers
        self.time = 0.0
        self.offset_time = 0.0    # The time stamp minus the initial start_time

    def update_time(self, cur_time):
        """
        Update the time for the sinusoidal signal generator class.
        This will be used internally to update the signal value that is generated by this class.

        Args:
            cur_time (float): THe current time in seconds.
        """
        self.time = cur_time
        if self.time > self.start_time:
            self.offset_time = self.time - self.start_time

    def get_value(self):
        """
            Return the value from the sin signal generator for the current offset time.
            The offset time only start incrementing after the start time has passed.
            If more time then self.duration has passed set the signal value back to the default.

        Returns:
            float: The vlaue of the signal at the current time.
        """
        sin_value = DEFAULT_CAN_VALUE
        if self.offset_time < self.duration:
            sin_value = self.amplitude * math.sin((self.offset_time / self.period) * 2.0 * math.pi)
        return sin_value

class CanMessage: # pylint: disable=too-few-public-methods
    """
    A Class to hold information about a CAN message. This stores both a dict contianing human readable data and raw can data.

    Args:
        name (string): The name of the CAN message.
        can_message (object): Cantools message object to store in this class.
    """
    def __init__(self, name, can_message):
        # Store the cantool can message definition and some additional info such as
        # all the signal values (in dict form) making up the current can message.
        # Why? We need to set the field values before encoding them into a CAN message to send on the Can bus.
        global DEFAULT_CAN_VALUE # pylint: disable=global-statement
        self.name = name
        self.can_message = can_message
        self.can_fields = {}
        self.can_data = None
        # Setup a dict storing all the field values for each CAN message
        for sig in can_message.signals:
            sig_name = sig.name
            self.can_fields[sig_name] = DEFAULT_CAN_VALUE

    def encode(self):
        """
        Encode the data writien in the can_fileds dict to raw CAN data and store it in can)data object.
        """
        # Encode the CAN messages so they are ready to be sent.
        self.can_data = self.can_message.encode(self.can_fields)


def create_signal_generator_dict(params):
    """

    Args:
        params (argparse.ArgumentParser): A dictionary containing all of the parameters
    Returns:
        dict: (of lists). Each dictionary element points to a list of objects that define
                     different signal generator types.
                     e.g signal_gen_dict["step_signal_generators"] points to a list storing CanStepSignalGenerator objects.
    """
    signal_gen_dict = {}

    # Create the step can signal generators.
    signal_gen_dict["step_signal_generators"] = []
    sig_dur = None
    sig_time = None
    if 'step_can_signals' in params:
        for step_msg_sig in params['step_can_signals']:
            sig_values = params['step_can_signals'][step_msg_sig]['value']
            if 'duration' in params['step_can_signals'][step_msg_sig]:
                sig_dur = params['step_can_signals'][step_msg_sig]['duration']
                signal_gen_dict["step_signal_generators"].append(CanStepSignalGenerator(step_msg_sig, sig_values, sig_dur, None))
            elif 'time' in params['step_can_signals'][step_msg_sig]:
                sig_time = params['step_can_signals'][step_msg_sig]['time']
                signal_gen_dict["step_signal_generators"].append(CanStepSignalGenerator(step_msg_sig, sig_values, None, sig_time))
            else:
                print("Failed to find a duration or time array specified in the step signal configuration for the signal {0}".format(step_msg_sig))

    # Create the sinusoidal can signal generators.
    signal_gen_dict["sinusoidal_signal_generators"] = []
    if 'sinusoidal_can_signals' in params:
        for sin_msg_sig in params['sinusoidal_can_signals']:
            sig_amplitude = params['sinusoidal_can_signals'][sin_msg_sig]['amplitude']
            sig_period = params['sinusoidal_can_signals'][sin_msg_sig]['period']
            sig_start_time = params['sinusoidal_can_signals'][sin_msg_sig]['start_time']
            sig_duration = params['sinusoidal_can_signals'][sin_msg_sig]['duration']

            signal_gen_dict["sinusoidal_signal_generators"].append(CanSinSignalGenerator(sin_msg_sig, sig_amplitude, sig_period, sig_start_time, sig_duration))

    return signal_gen_dict

def sig_gen_clock():
    """
    Get the time in seconds since the start of the test.

    Returns:
        float: time The number of seconds since the start of the test.
    """
    global START_TIME  # pylint: disable=global-statement
    if START_TIME is None:
        START_TIME = time.monotonic()
    return time.monotonic() - START_TIME

def get_total_times(params):
    """
    Go through the parameters and find the total time each signal should be sent for.

    Args:
        params (argparse.ArgumentParser): A dictionary containing all of the parameters
    Returns:
        dict: (name, float) The total number of seconds to send each signal for.
    """
    largest_time = 0.0
    total_time_dict = {} # A dictionary continaing the total time of each signal to be sent.
    # Check the step can signals.
    if 'step_can_signals' in params:
        for step_msg_sig in params['step_can_signals']:
            if 'duration' in params['step_can_signals'][step_msg_sig]:
                sig_dur = params['step_can_signals'][step_msg_sig]['duration']
                sum_sig_dur = sum(sig_dur)
                total_time_dict[step_msg_sig] = sum_sig_dur
                if (sum_sig_dur > largest_time):
                    largest_time = sum_sig_dur
            elif 'time' in params['step_can_signals'][step_msg_sig]:
                sig_time = params['step_can_signals'][step_msg_sig]['time']
                last_sig_time = sig_time[-1] # Get the last time defined.
                total_time_dict[step_msg_sig] = last_sig_time
                if (last_sig_time > largest_time):
                    largest_time = last_sig_time

    # Check the sinusoidal can signals.
    if 'sinusoidal_can_signals' in params:
        for msg_sig in params['sinusoidal_can_signals']:
            sig_start = params['sinusoidal_can_signals'][msg_sig]['start_time']
            sig_duration = params['sinusoidal_can_signals'][msg_sig]['duration']
            sum_sig_dur = sig_start + sig_duration
            total_time_dict[msg_sig] = sum_sig_dur
            if (sum_sig_dur > largest_time):
                largest_time = sum_sig_dur

    return total_time_dict

def get_can_messages_dict(can_db, params):
    """
    Go through the parameters and create a dictionary that stores CAN message class objects which contain the CAN feilds we want to publish.
    Note that there may be less can messages then signal names as multiple CAN message fields may be published in the same can message.

    Args:
        can_db (dict): A dict of cantools.database defining the CAN DBC file, loaded by python cantools library.
        params (dict): A dict of argparse.ArgumentParser containing all of the parameters
    Returns:
        dict: of CanMessage objects. These objects store the latest values for each each signal.
    """
    can_messages_dict = {}
    # Check the step can signals.
    if 'step_can_signals' in params:
        for step_msg_sig in params['step_can_signals']:
            # Can signals where stored as CAN_MESSAGE_NAME.MESSAGE_FIELD_NAME:
            can_message_name = step_msg_sig.split('.')[0]
            if (can_message_name not in can_messages_dict):
                example_message = can_db.get_message_by_name(can_message_name)
                can_messages_dict[can_message_name] = CanMessage(can_message_name, example_message)

    # Check the sinusoidal can signals.
    if 'sinusoidal_can_signals' in params:
        for step_msg_sig in params['sinusoidal_can_signals']:
            # Can signals where stored as CAN_MESSAGE_NAME.MESSAGE_FIELD_NAME:
            can_message_name = step_msg_sig.split('.')[0]
            if (can_message_name not in can_messages_dict):
                example_message = can_db.get_message_by_name(can_message_name)
                can_messages_dict[can_message_name] = CanMessage(can_message_name, example_message)

    return can_messages_dict

def encode_can_messages(last_sent_can_msgs):
    """
    Encode all the signal values and prepare the CAN messages to be sent

    Args:
        last_sent_can_msgs (dict): A dict containing the can messages that are to be written to the can bus but have not been encoded into raw CAN data.
    Returns:
        dict: A dict containing the can messages objects that are to be written to the can bus (this includes the raw encoded CAN messages).
    """
    for key, value in last_sent_can_msgs.items(): # pylint: disable=unused-variable
        value.encode()

    return last_sent_can_msgs

def write_to_can(last_sent_can_msgs, can_bus):
    """
    Write the given dict of can messages to the can bus interface.

    Args:
        last_sent_can_msgs (dict): A dict containing the can messages that are to be written to the can bus.
        can_bus (string): The CAN interface name e.g "can0"

    """
    for key, can_msg in last_sent_can_msgs.items(): # pylint: disable=unused-variable
        message = can.Message(arbitration_id=can_msg.can_message.frame_id, data=can_msg.can_data, is_extended_id=False)
        can_bus.send(message)

def fill_in_sin_can_fields(last_sent_can_msgs, sin_generators):
    """
    Fill in a dict of CAN messages with sinusoidal signals that are to be written to the CAN bus.

    Args:
        last_sent_can_msgs (dict): A dict containing the can messages that are to be written to the can bus.
        sin_generators (list): A list of CanSinSignalGenerator objects containing all of the parameters for generating sinusoidal signals.

    Return:
        dict: A dict containing the can messages that are to be written to the can bus.
    """
    for sin_sig in sin_generators:
        # For each signal generator object.
        #     1. Find the current duration time array index that is curently meant to be sent.
        #     2. From this index get the corresponding value that CAN field should have from the value array.
        #     3. Fill out this value in the corresponding CAN message.

        sin_sig.update_time(sig_gen_clock())
        # Get the corresponding value associated with the current duration and
        # fill in the CAN message with this fields value
        last_sent_can_msgs[sin_sig.can_name].can_fields[sin_sig.field_name] = sin_sig.get_value()

    return last_sent_can_msgs


def fill_in_step_can_fields(last_sent_can_msgs, step_generators):
    """
    Fill a dict of CAN messages with step wave signals that are to be written to the CAN bus.

    Args:
        last_sent_can_msgs (dict): A dict containing the can messages that are to be written to the can bus.
        step_generators (list): A list of CanStepSignalGenerator objects containing all of the parameters for generating step signals.

    Return:
        last_sent_can_msgs: A dict containing the can messages that are to be written to the can bus.
    """
    for step_sig in step_generators:
        # For each signal under the step_can_signals parameters:
        #     1. Find the current duration time array index that is curently meant to be sent.
        #     2. From this index get the corresponding value that CAN field should have from the value array.
        #     3. Fill out this value in the corresponding CAN message.

        step_sig.update_time(sig_gen_clock())
        # Get the corresponding value associated with the current duration and
        # fill in the CAN message with this fields value
        last_sent_can_msgs[step_sig.can_name].can_fields[step_sig.field_name] = step_sig.get_value()

    return last_sent_can_msgs

def run_can_sig_gen(can_db, params, can_bus):
    """
    Runs the signal generator. This sends generated signals for the CAN messages specified onto a CAN bus.

    Args:
        can_db (dict): (cantools.database) A dict defining the CAN DBC file, loaded by python cantools library.
        params (dict): (argparse.ArgumentParser): A dictionary containing all of the parameters
        can_bus (string): The can interface name e.g "can0"
    """
    can_write_rate = params['can_write_rate'] # The rate to send all CAN messages at [ Hz ]
    can_write_period = 1.0 / float(can_write_rate)

    end_sig_times = get_total_times(params)
    largest_time = max(end_sig_times.values())
    print("The test will run for", largest_time, " seconds")

    # Create a dict that will store the last can message sent.
    # Note:
    #             The paramter file has defined signals as CAN_MESSAGE_NAME.MESSAGE_FIELD_NAME
    #             This means before publishing a CAN message we need to populate all the signals that exist in that CAN message.
    #             This dict will store a can message and all the latest CAN field values making up that message.
    last_sent_can_msgs = get_can_messages_dict(can_db, params)

    # Create a dictionary of arrays of signal generator objects corresponding to the paremeter setup for each signal.
    signal_gen_dict = create_signal_generator_dict(params)

    # Main Loop
    test_timer = simtimer.SimTimer() # To print statistics on how well the main loop is doing.
    loop_counter = 0
    while sig_gen_clock() < largest_time:
        loop_counter += 1

        # Populate the step signal generator values.
        fill_in_step_can_fields(last_sent_can_msgs, signal_gen_dict["step_signal_generators"])
        # Populate the sinusoidal signal generator values.
        fill_in_sin_can_fields(last_sent_can_msgs, signal_gen_dict["sinusoidal_signal_generators"])

        # Encode the CAN messages (conver to raw CAN data).
        last_sent_can_msgs = encode_can_messages(last_sent_can_msgs)

        write_to_can(last_sent_can_msgs, can_bus)

        # Add timer to keep track of how quickly the test is running.
        test_timer.update()

        # Check to see if we should sleep. Sleeping period of less then 1ms for python becomes inaccurate.
        cur_time = sig_gen_clock()
        if (cur_time < (loop_counter * can_write_period)):
            # Try to sleep for a short time before looping.
            time.sleep((loop_counter * can_write_period) - cur_time)

    avg_write_rate = float(loop_counter) / float(largest_time)
    print("Average rate of sending CAN messages ", avg_write_rate, " Hz")
    print("Finished sending CAN messages.")

def connect_to_can_interface(interface_name, interface_type):
    """
    Connect to the can interface.

    Args:
        interface_name (string): The network interface e.g can0
        interface_type (string): The can interface type e.g socket_can or pcan
    Returns:
        can.interface.Bus: The can interfcae object.
    """

    # todo
    # Support other interface apart from socket Can. E.g The python can library easily supports kvaser, PCAN and other common CAN interfaces.
    can_bus = None
    if interface_type == "socketcan":
        can_bus = can.interface.Bus(interface_name, bustype=interface_type)

    return can_bus

def main(param_link):
    """
    Main function.

    Args:
        param_link (argparse.ArgumentParser): A dictionary containing all of the parameters
    """
    database = None
    # Load the parameters
    params = None
    if (param_link is not None):
        print("Configuration file is ", param_link.parameters)
        script_dir = os.path.dirname(__file__)
        abs_params_file_path = os.path.join(script_dir, param_link.parameters)
        with open(abs_params_file_path, "r") as p_stream:
            params = yaml.safe_load(p_stream)
            # Remove the top level yaml heading can_signal_generator
            params = params['can_signal_generator']

        # Load the DBC file parameter
        can_dbc_file_path = os.path.expanduser(params['can_dbc_file'])
        print("DBC file path is ", can_dbc_file_path)
        database = cantools.db.load_file(can_dbc_file_path)
    else:
        print("No parameters specified so we can't run the tool! Exiting.")
        sys.exit()

    # Connect to the Can bus
    can_bus = connect_to_can_interface(params['can_interface'], params['can_interface_type'])
    # Run the CAN signal generator test.
    if (database is not None) and (params is not None) and (can_bus is not None):
        run_can_sig_gen(database, params, can_bus)
    else:
        print("Something is not working and is a None type!")
        if database is None:
            print("Database is not loaded!")
        if params is None:
            print("The parameters where not loaded!")
        if can_bus is None:
            print("The can bus interface was not loaded!")

if __name__ == "__main__":
    print("Starting CAN generator tool.")
    PARSER = argparse.ArgumentParser(description='A python script to fill in CAN message feilds with generated signals. It publishes these messages onto a CAN bus at a speicfied rate.')
    PARSER.add_argument('-p', '--parameters',
                        help='A path to the parameter JSON file defining where the dbc file is located, what signals to generate and what CAN messages and fields to populate.')
    ARGS = PARSER.parse_args()
    main(ARGS)
